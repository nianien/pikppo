"""
Schema: Dub Manifest - SSOT for timeline-first dubbing pipeline.

The dub manifest captures all timing and content information needed for
TTS synthesis and audio mixing. It ensures:

1. audio_duration_ms is probed from the actual audio (not derived from utterances)
2. budget_ms = end_ms - start_ms (never negative, never from MT)
3. start_ms is fixed from ASR (immutable)

This is the contract between Align → TTS → Mix phases.
"""
from dataclasses import dataclass, field
from typing import List, Optional


@dataclass
class TTSPolicy:
    """
    Policy for handling TTS duration overflow.

    Fields:
    - max_rate: Maximum speech rate multiplier (e.g., 1.3 = 30% faster)
    - allow_extend_ms: Extra milliseconds allowed beyond budget (0 = strict)

    Processing logic:
    1. Synthesize raw TTS
    2. Trim silence
    3. If trimmed_duration > budget_ms:
       a. Calculate rate = trimmed_duration / budget_ms
       b. If rate > max_rate AND allow_extend_ms > 0:
          - extended_budget = budget_ms + allow_extend_ms
          - rate = trimmed_duration / extended_budget
       c. If rate still > max_rate: FAIL FAST
       d. Otherwise: apply rate adjustment
    """
    max_rate: float = 1.3
    allow_extend_ms: int = 0


@dataclass
class DubUtterance:
    """
    A single utterance in the dub manifest.

    Core timing fields (from ASR - IMMUTABLE):
    - utt_id: Unique identifier for this utterance
    - start_ms: Start time in milliseconds (from ASR, never modified)
    - end_ms: End time in milliseconds (from ASR, never modified)
    - budget_ms: Duration budget = end_ms - start_ms (must be positive)

    Content fields:
    - text_zh: Original Chinese text
    - text_en: Translated English text (for TTS)
    - speaker: Speaker identifier

    Optional fields:
    - tts_policy: Policy for handling duration overflow
    - emotion: Emotion tag (e.g., "sad", "happy")
    - gender: Gender tag (e.g., "male", "female")
    """
    utt_id: str
    start_ms: int
    end_ms: int
    budget_ms: int
    text_zh: str
    text_en: str
    speaker: str
    tts_policy: TTSPolicy = field(default_factory=TTSPolicy)
    emotion: Optional[str] = None
    gender: Optional[str] = None

    def __post_init__(self):
        """Validate budget_ms is consistent and positive."""
        expected_budget = self.end_ms - self.start_ms
        if self.budget_ms != expected_budget:
            raise ValueError(
                f"budget_ms ({self.budget_ms}) != end_ms - start_ms ({expected_budget}) "
                f"for utterance {self.utt_id}"
            )
        if self.budget_ms <= 0:
            raise ValueError(
                f"budget_ms must be positive, got {self.budget_ms} for utterance {self.utt_id}"
            )


@dataclass
class DubManifest:
    """
    The dub manifest - SSOT for the dubbing pipeline.

    Fields:
    - audio_duration_ms: Total audio duration from ffprobe (not from last utterance)
    - utterances: List of DubUtterance objects

    This manifest is:
    - Generated by: Align phase
    - Consumed by: TTS phase, Mix phase
    - Immutable after creation (timing comes from ASR)
    """
    audio_duration_ms: int
    utterances: List[DubUtterance]

    def __post_init__(self):
        """Validate manifest constraints."""
        if self.audio_duration_ms <= 0:
            raise ValueError(f"audio_duration_ms must be positive, got {self.audio_duration_ms}")

        # Validate all utterances
        for utt in self.utterances:
            if utt.end_ms > self.audio_duration_ms:
                raise ValueError(
                    f"Utterance {utt.utt_id} end_ms ({utt.end_ms}) exceeds "
                    f"audio_duration_ms ({self.audio_duration_ms})"
                )


def dub_manifest_to_dict(manifest: DubManifest) -> dict:
    """Serialize DubManifest to dict for JSON output."""
    return {
        "audio_duration_ms": manifest.audio_duration_ms,
        "utterances": [
            {
                "utt_id": u.utt_id,
                "start_ms": u.start_ms,
                "end_ms": u.end_ms,
                "budget_ms": u.budget_ms,
                "text_zh": u.text_zh,
                "text_en": u.text_en,
                "speaker": u.speaker,
                "tts_policy": {
                    "max_rate": u.tts_policy.max_rate,
                    "allow_extend_ms": u.tts_policy.allow_extend_ms,
                },
                "emotion": u.emotion,
                "gender": u.gender,
            }
            for u in manifest.utterances
        ],
    }


def dub_manifest_from_dict(data: dict) -> DubManifest:
    """Deserialize DubManifest from dict (JSON input)."""
    utterances = []
    for u in data["utterances"]:
        policy_data = u.get("tts_policy", {})
        policy = TTSPolicy(
            max_rate=policy_data.get("max_rate", 1.3),
            allow_extend_ms=policy_data.get("allow_extend_ms", 0),
        )
        utterances.append(
            DubUtterance(
                utt_id=u["utt_id"],
                start_ms=u["start_ms"],
                end_ms=u["end_ms"],
                budget_ms=u["budget_ms"],
                text_zh=u["text_zh"],
                text_en=u["text_en"],
                speaker=u["speaker"],
                tts_policy=policy,
                emotion=u.get("emotion"),
                gender=u.get("gender"),
            )
        )
    return DubManifest(
        audio_duration_ms=data["audio_duration_ms"],
        utterances=utterances,
    )
