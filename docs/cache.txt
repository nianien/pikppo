好的，按**“每一集（episode）维度”**把缓存重新定版：目标就是 同一集反复跑不重复合成，不考虑跨集复用，目录与命名严格贴合你现有结构（xxxx/dub/1、前缀 1-xxx）。

⸻

1) 目录与文件规范（确定）

输入目录：
	•	xxxx/1.mp4
	•	xxxx/2.mp4

输出工作目录（你要求）：
	•	xxxx/dub/1/
	•	xxxx/dub/2/

Episode 级缓存目录（新增/定版）

对 xxxx/dub/1/：

xxxx/dub/1/
  .cache/
    tts/
      azure/
        segments/
          <cache_key>.wav        # ✅ 每个 segment 的缓存音频（常驻）
        manifest.jsonl           # ✅ 本次/历史用过哪些 key（便于排查/清理）
  .temp_tts/                     # ✅ 运行期临时目录（可删）
    segments/
      seg_0001.wav               # 本次运行工作文件（来自缓存或新合成）
    tts_en.wav                   # 本次拼接产物（临时）
  1-tts.wav                      # 最终产物（常驻）
  1-tts-aligned.wav              # 最终产物（常驻）

.temp_tts 仍然按你现有逻辑删除；缓存放 .cache，不删。

⸻

2) 缓存粒度与命中规则（确定）

粒度：segment 级
	•	不缓存整段 tts_en.wav（拼接很快，不值）
	•	只缓存每个 segment 的 TTS 音频（ROI 最高）

命中条件（必须全部一致才算命中）
	•	normalized_text（规整后的文本）
	•	voice_id（声线）
	•	prosody（rate/pitch/style/role/volume…你用到哪些就纳入哪些）
	•	audio_format + sample_rate + channels（建议统一 wav 24k mono pcm）
	•	engine = azure
	•	engine_ver = v1（你自己写死，升级就改 v2）

⸻

3) cache_key 设计（确定）

3.1 文本规范化（避免无意义 miss）

对文本做：
	•	strip()
	•	连续空白合并为 1 个空格
	•	可选：统一中文/英文标点（建议先不做，v1 保守）

得到 text_norm

3.2 生成 payload（示例字段）

{
  "engine": "azure",
  "engine_ver": "v1",
  "voice": "en-US-JennyNeural",
  "lang": "en-US",
  "format": "wav",
  "sample_rate": 24000,
  "channels": 1,
  "prosody": {
    "rate": "0%",
    "pitch": "0%",
    "style": "general"
  },
  "text": "text_norm"
}

3.3 hash
	•	sha256(json.dumps(payload, sort_keys=True))
	•	文件名：<sha256>.wav

缓存文件路径：
	•	xxxx/dub/1/.cache/tts/azure/segments/<sha256>.wav

⸻

4) 运行时流程（你现有 pipeline 的最小侵入改造）

对每个 segment（有 idx、text、voice_id）：
	1.	计算 cache_key
	2.	cache_path = dub/1/.cache/tts/azure/segments/<key>.wav
	3.	如果 cache_path 存在：
	•	直接 copy/硬链 到：.temp_tts/segments/seg_{idx:04d}.wav
	4.	否则：
	•	调 Azure 合成 → 得到临时 wav
	•	写入 cache_path（原子写：先写 .tmp 再 rename）
	•	再 copy/硬链到 .temp_tts/segments/seg_{idx:04d}.wav
	5.	追加一条到 manifest.jsonl（一行一个 json）：
	•	{idx, key, voice_id, text_digest, created_at}

最后：
	•	拼接 .temp_tts/segments/*.wav → .temp_tts/tts_en.wav
	•	move → xxxx/dub/1/1-tts.wav
	•	alignment → xxxx/dub/1/1-tts-aligned.wav
	•	删除 .temp_tts（不影响缓存）

⸻

5) manifest.jsonl（v1 也很值得）

位置：
	•	xxxx/dub/1/.cache/tts/azure/manifest.jsonl

每条记录示例：

{"seg":1,"key":"<sha256>","voice":"en-US-JennyNeural","text_sha1":"...","ts":"2026-01-18T12:34:56+11:00"}

作用：
	•	debug：为什么没命中（voice 变了？文本变了？）
	•	清理：你可以按“本集曾经用到的 key”做精确清理（v2 再做引用计数也行）

⸻

6) 清理策略（episode 维度天然简单）
	•	删除 xxxx/dub/1/ 整个目录：缓存随之删除 ✅
	•	或删除 xxxx/dub/1/.cache/tts/：只清 TTS 缓存 ✅
	•	不需要全局 prune，不需要引用计数

⸻

7) v1 必须做的两个“防坑细节”
	1.	输出格式统一

	•	强烈建议缓存统一成 wav 24k mono pcm
	•	否则你拼接/对齐会出现多格式混用问题

	2.	原子写入缓存

	•	先写 cache_path.tmp，成功后 rename 到 cache_path
	•	避免中途崩溃留下半截文件导致下次误命中

⸻