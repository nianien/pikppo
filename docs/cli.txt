懂了：你要的是极简 Maven 生命周期——只保留：
	•	--to <phase>（必选）
	•	--from <phase>（可选，一旦给了，就从该 phase 开始强制刷新到 –to）

不要 --skip / --force / 一堆子命令。✅ 这个设计更像 mvn -DskipTests package 之前的“固定生命周期”。

下面我给你一套最简且可落地的规范（命令、phase 命名、执行规则、实现要点）。

⸻

1) 最终 CLI 形态（只剩两个参数）

基本用法

vsd run input.mp4 --to burn

断点续跑 + 强制刷新（你定义的语义）

vsd run input.mp4 --from asr-zh --to burn

语义必须是：
	•	没有 --from：能用缓存就用，只补齐到 --to
	•	有 --from X：从 X（含 X）到 –to 全部强制重跑（无视缓存）

⸻

2) Phase 命名（短、固定、可枚举）

按你描述的生命周期，给你一套最少且够用的 phases：
	1.	audio：提取 16k mono 音频（audio/1.wav）
	2.	asr-zh：ASR 输出中文句级 segments + subs/zh.srt
	3.	zh：中文后处理（可选，但我建议保留为独立 phase，方便你调规则）
	4.	en：翻译英文字幕（subs/en.srt）
	5.	tts：按 en.srt 合成配音（audio/tts.wav）
	6.	mix：混音（tts + accompaniment/ducking）输出 audio/mix.wav
	7.	burn：烧字幕 + 替换音轨（输出 video/final.mp4）

你如果坚决不要 zh/mix 两步，也行；但我建议保留 phase 颗粒度，否则后面调试会痛苦。

⸻

3) 产物目录（让缓存和刷新变得“天然”）

每个视频一个 workdir：

runs/<stem>/
  manifest.json
  audio/1.wav
  subs/zh.srt
  subs/zh.clean.srt
  subs/en.srt
  audio/tts.wav
  audio/mix.wav
  video/final.mp4


⸻

4) 缓存/刷新规则（你要的“强制刷新”）

没有 --from
	•	逐 phase 执行到 --to
	•	对每个 phase：
	•	如果 manifest 记录该 phase 已完成，且产物存在 → 跳过
	•	否则执行

有 --from X
	•	先把 manifest 中 X 以及之后 phases 的 done 标记全部置为 false
	•	然后从 X 跑到 --to
	•	这就实现了你要的：from 之后强制刷新

这比 --force 更干净：你只要一个开关就行。

⸻

5) 用户体验（像 Maven 一样）

常用命令

vsd run 1.mp4 --to asr-zh     # 只跑到识别
vsd run 1.mp4 --to en         # 跑到英文字幕
vsd run 1.mp4 --to burn       # 一键跑成片
vsd run 1.mp4 --from tts --to burn  # 只重做配音/混音/成片

打印生命周期列表（内置 help）

vsd phases
# audio -> asr-zh -> zh -> en -> tts -> mix -> burn


⸻

6) 实现核心（极简 runner 伪代码）

PHASES = ["audio","asr-zh","zh","en","tts","mix","burn"]

def run(video, to, from_=None):
    workdir = runs/<stem>
    manifest = load(workdir/manifest.json)

    if from_:
        # invalidate from_..end
        for p in PHASES[PHASES.index(from_):]:
            manifest["phases"][p]["done"] = False

    for p in PHASES[:PHASES.index(to)+1]:
        if manifest_done(manifest, p) and outputs_exist(manifest,p):
            continue
        outputs = PHASE_IMPL[p](video, workdir, cfg)
        manifest_mark_done(manifest, p, outputs)
        save(manifest)

这就是完整逻辑了：没有 skip，没有 force，没有子命令爆炸。

⸻

7) 我建议你把 “ASR 选用 vocals/raw” 做成 phase 内策略

你不用让 CLI 决策，asr-zh phase 内部做：
	•	默认用 vocals_16k_mono.wav
	•	如果 transcript 判坏 → fallback raw 或 fallback FunASR
	•	最终只输出一个 subs/zh.srt 给后面 phases 用

CLI 只关心生命周期，不关心模型细节。

